#+title: pebble-lang

* Prerequisites
- Requires Zig version =0.14.0= stable

* Usage

Run ~zig build run -- run filename~ to execute the interpreter pipeline on the contents of =filename=

or

run ~zig build run -- interactive~ to start the interactive REPL shell which supports expression evaluation and simple statements.
* Examples
** Sequential Fibonacci sequence

Computing the first =N= fibonacci numbers:
#+begin_src
declare N = 10
declare n1 = 1, n2 = 1, i = 1
while i <= N  {

      i = i + 1
      print n1

      declare TMP = n1
      n1 = n1 + n2
      n2 = TMP
}
#+end_src
which results in output
#+begin_example
1
2
3
5
8
13
21
34
55
89
#+end_example
** Function down-calling
#+begin_src
function f(a, b) return a + b * 3

function mod_fib(mod, n) {
    if n == 1 || n == 0 return 1
    return mod(mod_fib(mod, n-1), mod_fib(mod, n-2))
}

print mod_fib(f, 10)
#+end_src
gives output
#+begin_example
2683
#+end_example

** Recursive computation of Fibonacci numbers
#+begin_src
function fib(n) {
    if n == 1 || n == 0 return 1
    return fib(n-1) + fib(n-2)
}

print fib(10)
#+end_src
gives output
#+begin_example
89
#+end_example
** Lists
#+begin_src
function copy(dst, src) {
    declare idx = 0
    while idx < src.size {
        dst[idx] = src[idx]
        idx = idx + 1
    }
}

function append(list, item) {
    declare tmp[list.size + 1]
    copy(tmp, list)
    tmp[list.size] = item
    return tmp
}

declare mylist[4] = 0
print mylist

mylist = append(mylist, 1)
print mylist
#+end_src
gives output
#+begin_example
[0,0,0,0,]
[0,0,0,0,1,]
#+end_example

* Features
** Implemented
- Integer and boolean types
- Basic control flow (if and while)
- PRINT statements
- Basic lexical scoping
- ~break~ and ~continue~ statements
- COMMA declarations, e.g. ~declare x = 1, y = 2, z = 3~
- Function definitions and function calls
- Higher-order functions (passing functions as parameters)
- Lists with dynamic types using ~declare lst[size]~ syntax
- Comments prefixed with ~;~ or ~#~

** Not yet implemented
- String types
- Floating point types
- Structs
- For-loops
- INPUT statements
- Anonymous functions, e.g. lambda expressions
- Pass by reference

** Not planned
- Function up-calling (returning functions)
